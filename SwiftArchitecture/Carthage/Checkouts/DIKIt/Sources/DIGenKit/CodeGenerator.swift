//
//  CodeGenerator.swift
//  dikitgenTests
//
//  Created by Yosuke Ishikawa on 2017/09/16.
//

import Foundation
import SourceKittenFramework

public final class CodeGenerator {
    let moduleNames: [String]
    let resolvers: [Resolver]

    public convenience init(path: String, excluding exclusions: [String] = []) throws {
        try self.init(files: files(atPath: path, excluding: exclusions))
    }

    public init(files: [File]) throws {
        let types = try Array(files
            .map { file in
                return try Structure(file: file)
                    .substructures
                    .compactMap { Type(structure: $0, file: file) }
            }
            .joined())

        let imports = try Array(files
            .map { file -> [Import] in
                return try Import.imports(from: file)
            }
            .joined())
            .reduce([] as [Import]) { imports, newImport in
                return imports.contains(where: { $0.moduleName == newImport.moduleName })
                    ? imports
                    : imports + [newImport]
            }

        let resolvers = try types
            .compactMap { type -> Resolver? in
                do {
                    return try Resolver(type: type, allTypes: types)
                } catch let error as Resolver.Error where error.reason == .protocolConformanceNotFound {
                    return nil
                } catch {
                    throw error
                }
            }

        self.moduleNames = imports.map({ $0.moduleName }).sorted(by: <)
        self.resolvers = resolvers.sorted { (lhs, rhs) in return lhs.name < rhs.name }
    }

    public func generate() throws -> String {
        class Buffer {
            var result = ""
            var indentCount = 0
            
            func append(_ string: String) {
                for line in string.components(separatedBy: .newlines) {
                    guard !line.isEmpty else {
                        result += "\n"
                        continue
                    }
                    
                    var indent = ""
                    if indentCount > 0 {
                        indent = Array(repeating: "    ", count: indentCount).joined()
                    }
                    
                    result += "\(indent)\(line)\n"
                }
            }
        }
        
        let buffer = Buffer()
        
        buffer.append("""
        //
        //  Resolver.swift
        //  Generated by dikitgen.
        //
        """)
        
        buffer.append("")
        
        if !moduleNames.isEmpty {
            for moduleName in moduleNames {
                buffer.append("import \(moduleName)")
            }
            buffer.append("")
        }
        
        for resolver in resolvers {
            buffer.append("extension \(resolver.name) {")
            buffer.indentCount += 1
            
            for method in resolver.sortedGeneratedMethods {
                buffer.append("")
                
                buffer.append("func \(method.name)(\(method.parametersDeclaration)) -> \(method.returnTypeName) {")
                buffer.indentCount += 1
                
                for line in method.bodyLines {
                    buffer.append(line)
                }
                
                buffer.indentCount -= 1
                buffer.append("}")
            }
            
            buffer.append("")

            buffer.indentCount -= 1
            buffer.append("}")
        }

        return buffer.result
    }
}

private func files(atPath path: String, excluding exclusions: [String]) -> [File] {
    let exclusions = exclusions.map { $0.last == "/" ? $0 : $0 + "/" }
    let url = URL(fileURLWithPath: path)
    let fileManager = FileManager.default

    var files = [] as [File]
    var isDirectory = false as ObjCBool
    if fileManager.fileExists(atPath: url.path, isDirectory: &isDirectory) {
        if isDirectory.boolValue {
            let enumerator = fileManager.enumerator(atPath: path)
            while let subpath = enumerator?.nextObject() as? String {
                if exclusions.contains(where: { subpath.hasPrefix($0) }) { continue }

                let url = url.appendingPathComponent(subpath)
                if url.pathExtension == "swift", let file = File(path: url.path), file.contents.contains("DIKit") {
                    files.append(file)
                }
            }
        } else if let file = File(path: url.path) {
            files.append(file)
        }
    }

    return files
}
